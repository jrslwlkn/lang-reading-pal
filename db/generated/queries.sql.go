// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const addChunk = `-- name: AddChunk :exec
insert into
    chunks (
        doc_id,
        position,
        value,
        suffix
    )
values
    (?1, ?2, ?3, ?4)
`

type AddChunkParams struct {
	DocID    int64
	Position int64
	Value    string
	Suffix   string
}

func (q *Queries) AddChunk(ctx context.Context, arg AddChunkParams) error {
	_, err := q.db.ExecContext(ctx, addChunk,
		arg.DocID,
		arg.Position,
		arg.Value,
		arg.Suffix,
	)
	return err
}

const addDoc = `-- name: AddDoc :one
insert into
    docs(
        title,
        author,
        body,
        notes,
        lang_id,
        user_id,
        added_at,
        term_count,
        sentence_count,
        terms_new
    )
values
    (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        datetime(),
        0,
        0,
        0
    ) returning doc_id
`

type AddDocParams struct {
	Title  string
	Author string
	Body   string
	Notes  string
	LangID int64
	UserID int64
}

func (q *Queries) AddDoc(ctx context.Context, arg AddDocParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addDoc,
		arg.Title,
		arg.Author,
		arg.Body,
		arg.Notes,
		arg.LangID,
		arg.UserID,
	)
	var doc_id int64
	err := row.Scan(&doc_id)
	return doc_id, err
}

const addLang = `-- name: AddLang :one
insert into
    langs(
        name,
        from_id,
        to_id,
        quick_lookup_uri,
        lookup_uri_1,
        lookup_uri_2,
        chars_pattern,
        sentence_sep,
        added_at,
        user_id
    )
values
    (
        ?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        datetime(),
        ?9
    ) returning lang_id
`

type AddLangParams struct {
	Name           string
	FromID         string
	ToID           string
	QuickLookupURI string
	LookupURI1     string
	LookupURI2     string
	CharsPattern   string
	SentenceSep    string
	UserID         int64
}

func (q *Queries) AddLang(ctx context.Context, arg AddLangParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addLang,
		arg.Name,
		arg.FromID,
		arg.ToID,
		arg.QuickLookupURI,
		arg.LookupURI1,
		arg.LookupURI2,
		arg.CharsPattern,
		arg.SentenceSep,
		arg.UserID,
	)
	var lang_id int64
	err := row.Scan(&lang_id)
	return lang_id, err
}

const addTerms = `-- name: AddTerms :exec
insert into
    terms(
        value,
        translation,
        term_level_id,
        lang_id,
        user_id,
        added_at
    )
select
    value,
    '',
    1,
    d.lang_id,
    d.user_id,
    datetime()
from
    chunks c
    join docs d on c.doc_id = d.doc_id
where
    d.doc_id = ?1
    and not exists (
        select
            value
        from
            terms
        where
            user_id = (
                select
                    user_id
                from
                    docs
                where
                    doc_id = d.doc_id
            )
    )
group by
    value
`

func (q *Queries) AddTerms(ctx context.Context, docID int64) error {
	_, err := q.db.ExecContext(ctx, addTerms, docID)
	return err
}

const getAllLangs = `-- name: GetAllLangs :many
select
    id,
    name
from
    langs_dim
`

func (q *Queries) GetAllLangs(ctx context.Context) ([]LangsDim, error) {
	rows, err := q.db.QueryContext(ctx, getAllLangs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LangsDim
	for rows.Next() {
		var i LangsDim
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocBody = `-- name: GetDocBody :many
select
    c.value,
    c.suffix,
    t.term_level_id,
    t.translation
from
    chunks c
    left join terms t on c.value = t.value
where
    c.doc_id = ?1
    and t.user_id = ?2
`

type GetDocBodyParams struct {
	DocID  int64
	UserID int64
}

type GetDocBodyRow struct {
	Value       string
	Suffix      string
	TermLevelID sql.NullInt64
	Translation string
}

func (q *Queries) GetDocBody(ctx context.Context, arg GetDocBodyParams) ([]GetDocBodyRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocBody, arg.DocID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocBodyRow
	for rows.Next() {
		var i GetDocBodyRow
		if err := rows.Scan(
			&i.Value,
			&i.Suffix,
			&i.TermLevelID,
			&i.Translation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocMeta = `-- name: GetDocMeta :one
select
    doc_id,
    title,
    author,
    added_at,
    term_count,
    terms_new,
    sentence_count
from
    docs
where
    doc_id = ?1
`

type GetDocMetaRow struct {
	DocID         int64
	Title         string
	Author        string
	AddedAt       time.Time
	TermCount     int64
	TermsNew      int64
	SentenceCount int64
}

func (q *Queries) GetDocMeta(ctx context.Context, id int64) (GetDocMetaRow, error) {
	row := q.db.QueryRowContext(ctx, getDocMeta, id)
	var i GetDocMetaRow
	err := row.Scan(
		&i.DocID,
		&i.Title,
		&i.Author,
		&i.AddedAt,
		&i.TermCount,
		&i.TermsNew,
		&i.SentenceCount,
	)
	return i, err
}

const getDocs = `-- name: GetDocs :many
select
    doc_id,
    title,
    author,
    added_at,
    term_count,
    terms_new,
    sentence_count
from
    docs
where
    user_id = ?1
`

type GetDocsRow struct {
	DocID         int64
	Title         string
	Author        string
	AddedAt       time.Time
	TermCount     int64
	TermsNew      int64
	SentenceCount int64
}

func (q *Queries) GetDocs(ctx context.Context, userID int64) ([]GetDocsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocsRow
	for rows.Next() {
		var i GetDocsRow
		if err := rows.Scan(
			&i.DocID,
			&i.Title,
			&i.Author,
			&i.AddedAt,
			&i.TermCount,
			&i.TermsNew,
			&i.SentenceCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLangs = `-- name: GetLangs :many
select
    lang_id,
    name
from
    langs
where
    user_id = ?1
`

type GetLangsRow struct {
	LangID int64
	Name   string
}

func (q *Queries) GetLangs(ctx context.Context, userID int64) ([]GetLangsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLangs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLangsRow
	for rows.Next() {
		var i GetLangsRow
		if err := rows.Scan(&i.LangID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDocStats = `-- name: UpdateDocStats :exec
update
    docs
set
    term_count = ?1,
    sentence_count = ?2
where
    doc_id = ?3
`

type UpdateDocStatsParams struct {
	TermCount     int64
	SentenceCount int64
	DocID         int64
}

func (q *Queries) UpdateDocStats(ctx context.Context, arg UpdateDocStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateDocStats, arg.TermCount, arg.SentenceCount, arg.DocID)
	return err
}
